# 死锁

## 死锁是什么？

我想可以这样比喻死锁：

A、B 两人交易，A 有钱，B 有货。

A 说：「B 得先交货，我才能给钱」。

B 说：「不行，A 得先给钱，我才能交货」。

然后双方僵持不下，发生了「死锁」。

## C# 中的`lock`

`lock`的作用是锁定某一代码块，让同一时间只有一个线程能访问该代码块：

```c#
lock(X)
{
  //需要锁定的代码.... 
}
```

这里之所以能锁定代码的关键就在于`X`这个对象，`X`是任意一种引用类型。任何一个线程执行到`lock(X)`后，需要独享`X`才能执行下面的代码块，`X`被独享时，其它线程就算执行到`lock(X)`也只能暂停排队，已独享`X`的线程执行完这个代码块后才失去对`X`的独享，然后正在排队的首个线程才能接着独享`X`以执行下面的代码块。

## C# 中的死锁举例

假定有两个类：

- `class A{}`
- `class B{}`

有两个公共对象：

- `A a=new A(); `
- `B b=new B(); `

首先在 A 中若有一方法内的代码需要锁定：

```C#
lock(this)//this在这里就是a 
{ 
    //.... 
    lock(b) 
    { 
        //...... 
    } 
} 
```


然而此时 B 中某方法也有如下代码需要锁定：

```C#
lock(this)//this在这里就是b
{ 
    //.... 
    lock(a) 
    { 
        //...... 
    } 
} 
```

A 类中执行到`lock(this)`后`a`被占有，B 类中执行到`lock(this)`后`b`被占有，然后 A 类需要`b`，B 类需要`a`，此时双方两个需要的对象都被对方占有，出现僵持状态，程序死锁了。

所以要避免发生死锁，就得避免要独占（锁定）的对象在另一个地方被意外独占，所以要尽量缩小这个对象的被访问范围，要避免将`public`的对象作为锁定对象，应该锁定被访问范围较小的对象。
