# 解耦、抽象类、接口、反射

## 解耦

松耦合最大的好处就是可以让功能的提供方变得可替换，从而降低紧耦合时功能（服务）的提供方不能被替换所带来的高风险和高成本。

- 高风险指的是一旦功能（或者说服务，下同）的提供方本身有问题就导致依赖在它上面的其它的类和功能都不能正常工作。
- 高成本指的是如果功能的提供方开发进度慢了就可能导致整个团队工作受阻。

解耦在代码中的表现就是依赖反转（类与类之间的依赖反转为类对接口的依赖），单元测试就是依赖反转在开发中的直接应用和直接受益者。

## 抽象类

抽象类是未完全实现逻辑的类（可以有字段和非 public 成员）。抽象类为复用而生，专门作为基类来使用，也具有解耦功能。有抽象成员的类就是抽象类，抽象成员的访问级别不能为`private`。

## 接口

接口和抽象类都是「软件工程产物」。具体类→抽象类→接口：越来越抽象，内部实现的东西越来越少。封装确定的，开放不确定的，推迟到合适的子类中去实现。接口和抽象类都不能实例化，只能用来声明变量、引用具体类（concrete class）的实例。

接口是完全未实现逻辑的「类」，也叫「纯虚类」，只有函数成员，成员的访问控制为全部隐式 public。

![](C:/My/1-BinaryFiles/9-MarkdownFileImages/2019-05-01-C-Sharp-%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E8%AF%A6%E8%A7%A3-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1558934589094.jpg)

接口隔离原则指的是：如果一个接口中有过多功能的调用者不需要的功能，就要把本质不同的功能隔离开，再用多个接口封装起来。接口隔离原则是站在服务调用者的角度来看接口，单一职责原则是站在服务提供者的角度来看接口。接口隔离遵循了 SOLID 中的依赖反转，开闭原则。

C# 中接口的实现：隐式，显式，多接口（一个类或接口可以实现多个接口）。

在代码中如果有可以替换的地方，就可以有接口的存在，接口就是为了解耦而生，让单元测试更方便。

## 反射与依赖注入

反射：以不变应万变（更松的耦合），利用反射可以在程序运行时动态获取类型。

依赖注入：此 DI（依赖注入） 非彼 DI（依赖反转），但没有彼 DI 就没有此 DI。

