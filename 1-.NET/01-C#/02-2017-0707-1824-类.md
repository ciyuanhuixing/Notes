# 类

类是一种数据结构，它可以包含数据成员（常量和字段）、函数成员（方法、属性、事件、索引器、运算符、实例构造函数、静态构造函数和析构函数）以及嵌套类型。类类型支持继承，继承是一种机制，它使派生类可以对基类进行扩展和专用化。——《C# 语言规范》

C# 是完全面向对象的语言。面向对象的三个基本特征是：封装、继承、多态。

有两种面向对象的实现风格：

- Class-based（C#、C++、Java）
- Prototype-based（JavaScript）

## 命名空间

命名空间（namespace）以树形结构组织类（其他类型）。命名空间的作用是对类进行分类，这样当不同的`class`同名时就能避免冲突。

如果不对相应的名称空间进行`using`，在代码中调用类时就需要在类前面加上对应的名称空间和`.`，用来限定该类的名称空间。

如果代码中调用的类没有写明名称空间，怎么才能知道这个类的名称空间？

- 查文档。
- 在 VS（Visual Studio 的简称，下同）中，在类名上按下快捷键`Ctrl`+`.`就能弹出对应名称空间的智能标记。

## 类库的引用

类库，即类的仓库。命名空间和类是放在类库中的，类库引用是使用命名空间和类的物理基础。VS 中不同的项目模板本质上就是在建立模板时自动引用了不同技术所需要的类库。

### DLL 引用（黑盒引用，无源代码）

DLL 文件是类库代码编译后生成的文件，在 VS 中可以对第三方的 DLL 文件添加引用，也可以引用系统自带的 DLL，系统自带的 DLL 在引用时要在 Assemblies（程序集）中选择。

DLL 引用有个缺点：因为没有 DLL 文件的源代码，所以当 DLL 中的代码错误时无法修改它。

NuGet 简介：

程序对类库的依赖关系一般有很多层，每个类库可能又有不同的版本，这样在手动引用类库时就比较繁琐且容易出错。在 VS 中使用 NuGet 就能以一组包的形式来引用某个类库，NuGet 能自动下载所需要的类库，并把上层类库所引用的底层类库自动引用进来。

### 项目引用（白盒引用，有源代码）

一个项目可以被包含在多个解决方案中，也就是说一个项目可以被多个解决方案引用。在 VS 中可以为当前解决方案添加已存在的项目，然后引用这个项目。

在 VS 中可以给解决方案添加一个新的类库（Class Library）项目，然后可以在这个项目中写代码，并在解决方案中引用这个项目。

因为有引用项目的源代码，所以可以直接修改其中出现的错误。

## 依赖关系

依赖关系也叫类（或对象）之间的耦合关系。

类与类之间、类库与类库之间一旦相互引用，它们之间就产生了依赖关系。依赖关系在软件质量当中起着至关重要的作用，质量好的软件依赖关系清晰、容易维护，质量差的则依赖关系不清楚。一旦所依赖的类库代码出现错误，依赖它的程序也会出现错误，所以要尽量减轻代码的依赖关系。

优秀的程序追求「高内聚，低耦合」，目的是让程序结构更清晰。

- 「高内聚」指的是，数据和功能该属于哪个类，就精确地放在哪个类里面，类该归类到哪个类库里面，就放在哪个类库里面。
- 「低耦合」指的是类与类之间、类库与类库之间的依赖关系要尽可能的低。

UML（通用建模语言）类图用来展现类与类之间的关系。

![UML 类图](C:/My/1-BinaryFiles/9-MarkdownFileImages/2019-05-01-C-Sharp-%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E8%AF%A6%E8%A7%A3-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1556710124963.jpg)

## 类是现实世界事物的模型

类代表现实世界中的「种类」。类是对现实世界事物进行抽象所得到的结果。事物包括「物质」与「运动」。

- 「物质」对应软件工程中的「实体」。
- 「运动」是物质之间的关系和作用，对应软件工程中的「逻辑」。

现实世界中由物质和运动构成系统，软件工程中由实体和逻辑构成系统。

建模是一个去伪存真（去掉事物在程序中用不到的东西）、由表及里（表指的是接口，里指的是封装起来的内部逻辑）的过程。

## 类、对象、实例三者的关系

类对应现实世界中的事物，事物是很多具有相同特征的个体抽象出的概念。对象对应现实世界中的个体。

对象也叫实例，是类经过「实例化」后得到的内存中的实体。依照类，可以创建对象，这就是「实例化」。

- 有些类不能实例化，比如「数学」（Math Class），我们不能说「一个数学」。
- 使用`new`操作符可以创建类的实例。

对象与实例并无太大区别，常常混用，只是有时用词的语境稍有不同，在讨论现实世界相关的语境时常用「对象」，在讨论程序相关的语境时常用「实例」。

引用变量与实例的关系：

- 通过引用变量引用一个实例后，就可以多次访问这个实例。
- 引用变量可以不引用实例，实例也可以不被引用，多个引用变量可以引用同一个实例。

## 类的成员

### 构造器与析构器

即构造函数与析构函数，析构函数由编译器自动生成。

### 字段

字段一种表示与对象或类型（类型包括类与结构体）关联的变量。

字段的初始值：

- 无显示初始化时，字段获得其类型的默认值，所以字段「永远都不会未被初始化」。
- 实例字段初始化的时机——对象创建时。
- 静态字段初始化的时机——类型被加载时。

### 属性

属性是一种用于访问对象或类型的特征的成员，特征反映了状态。属性是字段的自然扩展。属性由 Get/Set 方法对进化而来，是一个「语法糖」。

属性的作用：

- 对类的外部：暴露数据，数据可以是存储在字段里的，也可以是动态计算出来的。
- 对类的内部：保护字段不被非法值「污染」。

属性的声明：

- 完整声明——有字段与访问器。
- 简略声明——只有访问器。
- 只读属性：只有 getter 没有 setter。
- 尽管语法上正确，几乎没有人使用「只写属性」，因为属性的主要目的是通过向外暴露数据而表示对象、类型的状态。

属性与字段的关系：

- 一般情况下，它们都用于表示实体（对象或类型）的状态。
- 属性大多数情况下是字段的包装器（wrapper）。
- 建议：永远使用属性（而不是字段）来暴露数据，即字段的访问级别永远都是 private 或 protected。

### 方法

方法由 C 语言中的函数（function）进化而来，表示类或对象「能做什么」。

程序就是用算法来加工数据，方法就是算法，属性就是数据。

### 事件

类或对象通知其它类或对象的机制，为 C# 所特有（Java 通过其它方法实现这个机制）。

### 常量

常量是**可以在编译时计算**的值。常量隶属于类型而不是对象，即没有「实例常量」。实例常量的角色由「只读实例字段」来担当。注意区分成员常量与局部常量。

各种「只读」类成员的应用场景：

- 为了提高程序可读性和执行效率：使用常量。
- 为了防止对象的值被改变：使用只读字段。
- 向外暴露不允许修改的数据：使用只读属性（静态或非静态）。
- 当希望成为常量的值其类型不能被常量声明接受时（类/自定义结构体）：使用静态只读字段。

### 索引器

它使对象能够用与数组相同的方式（即使用下标）进行索引。注意：没有静态索引器。

## 使用成员的侧重点

某些特殊类或对象使用成员的侧重点不同：

- 模型类或对象重在属性，如使用 Entity Framework 的模型类。
- 工具类或对象重在方法，如 `Math`，`Console`。
- 通知类或对象重在事件，如各种 `Timer`。

## 静态成员与实例成员

静态成员在语义上表示它是**类的成员**，也就是说这个成员是隶属于类的，类的对象无法访问静态成员。

实例成员在语义上表示它是**对象的成员**，也就是说这个成员是隶属于每个具体对象的，类无法访问实例成员。

绑定（Binding）指的是编译器如何把一个成员与类或对象关联起来。「早绑定」指的是编译器在编译一个类时就知道某个成员是率属于类还是类的对象，「晚绑定」指的是直到程序运行起来后才由程序来决定某个成员是隶属于类还是类的对象。有晚绑定功能的语言一般叫作**动态语言**，比如 JavaScript。

